# Folding

## Summary

This RFC proposes the addition of folding support to Kimchi, and more generally
to any Plonk-ish constraint system described by a multi-variate polynomial
$P[X_{1}, \cdots, X_{N}] \in \mathbb{K}[X_{1}, \cdots, X_{N}]$. Folding is
a technique which basically allows to prove two instances of a relation for the
price of one, enabling the development of efficient incrementally verifiable
computation (or shortly, IVC). A concrete usecase, o1VM, a zero-knowledge
virtual machine, will be given as an example.

Folding has been introduced by the paper
[Nova](https://eprint.iacr.org/2021/370). Nova is an accumulation scheme, by that it means
Nova allows a prover to accumulate instances of a given relation and instead of
generating a proof for each instance, the prover only needs to generate a single
proof at the end of an accumulated instance.
While [Halo](https://eprint.iacr.org/2019/1021.pdf) accumulates the proofs (i.e.
the "output" of the SNARK) and forces the prover to encode the verification of
the SNARK in the circuit, folding schemes focus on accumulating the instances
(i.e. the "input" of the SNARK). It is a more lightweight method to provide
IVC as the accumulation of the (committed) inputs can be less expensive to
encode in a circuit.

In this document, we will describe a variant/generalisation of Nova which can be
used to fold any type of multi-variate polynomials, over any number of
variables. We will also show how to generalize it when the relation is described
by a list of constraints.
Finally we will sketch the circuit we use to encode the verification over the
same curve, which differs from most (currently known) attempts in the
litterature and industry based on a cycle of curves.

## Motivation

o1VM, our zero-knowledge virtual machine, aims to support long traces, longer
than the size of the structure reference string (a.k.a SRS) available. For
traces shorter than the SRS, a $\mathcal{PlonK}$-ish proof can easily be
generated by implementing a generalisation of the polynomial IOP $\mathcal{PlonK}$.

To support an arbitrary number of cycles we will
need some kind of recursion that allows us to combine blocks of cycles in a way
that will allow constant size proofs.
Pickles is able to do it, but not while fulfilling the performance requirements for o1VM.
Folding is a less powerful alternative, but powerful enough while offering
superior performance, especially in the specific scenario where o1VM has to operate.

It is not a goal to replace Pickles, but we want to provide an alternative for cases
where folding can be a better option.

## Detailed design

We do suppose the reader knows how Nova can be used to fold relations described
by the computational model R1CS. A quick remark is that R1CS is a particular
case of constraints defined by multilinear polynomials (i.e. multi-variate
polynomials of degree $1$). More precisely, a constraint in R1CS is described by
three multi-variate polynomials $P_{1}(X_{1}, \cdots, X_{N})$,
$P_{2}(X_{1},
\cdots, X_{N})$ and $P_{3}(X_{1}, \cdots, X_{N})$ in $\mathbb{K}[X_{1}, \cdots,
X_{N}]$ such that:
- $P_{1}$, $P_{2}$, $P_{3}$ are of degree $1$, i.e. are multilinear polynomials.
- $P_{1}(X_{1}, \cdots, X_{N}).P_{2}(X_{1}, \cdots, X_{N}) = P_{3}(X_{1},
  \cdots, X_{N})$

In the rest of the document, we will generalize it for multi-variate polynomial
of degree $2$. For polynomials with a degree higher than 2, we perform a step
before folding, called
[quadricization](./0008-kimchi-polynomial-quadricization.md), consisting of
reducing the multi-variate polynomials to an equivalent system of multi-variate
polynomials of degree 2, and we will randomize them as explained after.

### Overview of folding

The general idea of folding is a protocol which starts with 2 instance-witness
pairs, the prover has access to everything, while the verifier only to the instance.
At the end of the protocol, a new instance-witness pair will be created, with
the property that verifying it implies verifying the 2 original pairs.
That way, the prover only has to do 1 actual proof, and the verifier only has to
verify 1 proof, the new pair can become an input of the protocol too, thus
allowing to fold an arbitrary number of instance-witness pairs into a single
one.

### Folding in Kimchi

For Kimchi, the witness is the same witness we already have: a list of
columns/polynomials. The instance is list of the commitments to those
polynomials, plus the public inputs.

Additionally, to make folding work we need to add 2 things that will absorb
errors generated during the folding, one is just
a field element $u$, the other is an extra witness column $E$ with its
corresponding commitment $\overline{E}$ in the instance.

We will call this new kind of instance a _relaxed Kimchi instance_ (equivalent
to the committed relaxed R1CS instance in Nova, but we already had commitments
so the only change is the relaxation).

A normal Kimchi instance-witness pair can be trivially converted into relaxed
kimchi by just setting $U=1$ and $E=[0;N]$.

The verifier part of the protocol is relatively simple: get some commitments for
the errors generated, make a challenge, send
the challenge to the prover and take a linear combination of the instances using
the challenge.

The prover is doing the same with the witness after computing the error and
committing to them.

### Implementation

The implementation will just be a few functions, working with relaxed instances and witnesses:

```rust
struct Instance;
struct Witness;
struct Challenge;
struct Error(Evals);

fn compute_error(a: &Instance,b: &Instance) -> Error;
fn fold_instance(a: Instance, b: Instance, error: Error) -> (Instance, Challenge);
fn fold_witness(a: Instance,b: Instance) -> (Instance, Challenge);
```

Additionally, it may be necessary to create some transformation that will add
the errors to the kimchi equation so that the verification will work again.

Given that another RFC will make the degree fixed to 2, it should be possible to
make a function that will map expressions to the their relaxed version and apply
it to each expression used.

### Transformation

We can think that all kimchi expressions will ultimately aggregate into a
multivariate polynomial, thanks to the [quadricization
RFC](./0008-kimchi-polynomial-quadricization.md), we can additionally assume it
to be of degree 2 or less.

To support the general case, let's use a small example.
Let's suppose the constraint system is described by the multi-variate polynomial
$P(X_{1}, X_{2}, X_{3}) = X_{1} X_{2} + (1 - X_{3})$.

As described below, and as described in more detail in the Nova paper, a
folding scheme will consist as a first step in "relaxing" the polynomial $P$ in
a polynomial that can handle "random linear combinations" of instances. In other
terms, the polynomial $P(X_{1}, X_{2}, X_{3})$ will be transformed into a
polynomial $P'(X_{1}, X_{2}, X_{3}, u)$ and the constraint will become
$P'(X_{1}, X_{2}, X_{3}, u) + E = 0$. The term $E$ is called the _error term_.

A more general observation from the transformation performed in the Nova paper
shows that the monomials of the polynomial $P$ must be changed in the following
way:

- Constant: Will be multiplied by $u^2$
- Degree $1$: Will be multiplied by $u$
- Degree $2$: Unchanged.

For our small example, let's take two instances $I = (X_{1}, X_{2}, X_{3}, u)$ and
$I' = (X'_{1}, X'_{2}, X'_{3}, u')$, coin a random combiner $r$ and compute the folded
instances $I'' = I + r I'$ in the following way:

- $X_{1} + r X'_{1}$
- $X_{2} + r X'_{2}$
- $X_{3} + r X'_{3}$
- $u + r u'$

Following the observation on the monomials given above, the polynomial
$P'(X_{1}, X_{2}, X_{3}, u) = X_{1} X_{2} + u (u - X_{3})$.

If we expand $P'$ for $I''$, we have:

```math
\begin{align*}
   & (X_{1} + r X'_{1}) \, (X_{2} + r X'_{2}) + (u + r u') \, [(u + r u') - (X_{3} + r X'_{3})] \\
 = & \, X_{1} X_{2} + r X_{1} X'_{2} + r X'_{1} X_{2} + r X'_{1} \, r X'_{2} \\
 + & \, u \, [(u + ru') - (X_{3} + r X'_{3})] + r u' \, [(u + ru') - (X_{3} + r X'_{3})] \\
 = & \, X_{1} X_{2} + r X_{1} X'_{2} + r X'_{1} X_{2} + r X'_{1} \, r X'_{2} \\
 + & \, u \, (u - X_{3}) + u \, (r u' - r X'_{3}) + r u' \, (r u' - r X'_{3}) + r u' (u - X_{3}) \\
 = & \, X_{1} X_{2} + r X'_{1} \, r X'_{2} + r X_{1} X'_{2} + r X'_{1} X_{2} \\
 + & \, u \, (u - X_{3}) + r u' \, (r u' - r X'_{3}) + r u' (u - X_{3}) + u \, (r u' - r X'_{3}) \\

 = & \overbrace{\, X_{1} X_{2} + \, u \, (u - X_{3})}^{P'(X_{1}, X_{2}, X_{3}, u)} \\
 + & \underbrace{\, r X'_{1} \, r X'_{2} + r u' \, (r u' - r X'_{3})}_{P'(r X'_{1}, r X'_{2}, r X'_{3}, r u')} \\
 + & \underbrace{r u' (u - X_{3}) + u \, (r u' - r X'_{3}) + X_{1} r X'_{2} + r X'_{1} X_{2}}_{\text{error term/cross term}} \\

\end{align*}
```

To compute the error terms $E$, we will express the evaluations of relaxed
polynomial $P'$ at the folded instances using the original instances.
When generalizing the example above, we notice that the error terms can be
computed using the mononimals.

#### Error contribution

In general, when taking the linear combination of a term, you will get 3 parts,
each multiplied by $1$, $r$ or $r^2$. The part multiplied by $r$ is the error
contribution.

Here $u_1$ and $u_2$ are the scalars from each of the original instances that
become the $u = u_1 * ru_2$ of the new folded instance, same notation is use
when needed for witness columns.

Also, $S$ will represent a selector, which can be multiplying in the term, but
does not affect the degree.

- Constant: For some term $P$, the contribution will be $r^{2} u_{1} u_{2} P$,
  we can likely add all terms together and multiply by $r^{2} u_{1} u_{2}$ at
  the end.
- Degree $1$: For some term $P$, the contribution will be $r (u_{1} P_{2} +
  u_{2} P_{1})$. A similar optimization as above should be possible.
  Here $P_1$ for example just means that for computing the expression we use a
  column from the first instance (the one with $u_{1}$).
- Degree $2$: for some term $P$, that contains $ab$ from the witness, the
  contribution will be $r (a_{1} b_{2} + a_{2} b_{1})$

Given that they all contain $r$, it can be omitted and multiplied to the entire
$E$ at the end.

## Test plan and functional requirements

1. Testing goals and objectives:
    - The only requirement would be for it to work, it doesn't need backwards
      compatibility given that it will be first used in o1VM.
2. Testing approach:
    - Given that it is new and not a replacement for Pickles, we are likely
      limited to unit test it.
    - When o1VM is ready, just running it with folding would be a useful test.

## Drawbacks

There isn't much not already mentioned about the comparison with pickles.

## Rationale and alternatives

The alternative would be Pickles, which as explain at the start, wouldn't meet
the performance requirement for the ZkVM.

## Unresolved questions

- We should probably add the equations here to some detail.
- It is probably better to explain in detail the process to convert the kimchi
  expressions in their relaxed version.
